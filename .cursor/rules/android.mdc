---
description: 안드로이드 기본 규칙
globs: **/com/minhyuuk/dashnote/**
alwaysApply: true
---
You are a Senior Kotlin programmer with experience in the Android framework and a preference for clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## Kotlin General Guidelines

### Basic Principles

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using any.
  - Create necessary types.
- Don't leave blank lines within a function.

### Nomenclature

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use underscores_case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions

- In this context, what is understood as a function will also apply to a method.
- Write short functions with a single purpose. Less than 20 instructions.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO
  - Use an object to pass multiple parameters.
  - Use an object to return results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Data

- Use data classes for data.
- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as val for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properties.

### Exceptions

- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
  - Otherwise, use a global handler.

## Specific to Android
### Basic Principles
	- Use Material 3 for all UI components.
	- Follow the MVVM architecture pattern consistently: ViewModel holds UI state, Repository handles data source logic, and Composables observe state via StateFlow or UiState.
	- Apply Jetpack Compose for all UI development. Avoid using XML layouts.
	- Inject all dependencies using Hilt. Avoid manual dependency management or ServiceLocator.
	- Use @HiltViewModel for ViewModel instantiation in Compose.
	- Use Repository pattern as the single source of truth for accessing network, database, or local data. Never call DAOs or APIs directly in ViewModels.
	- Declare UI state as an immutable UiState data class and expose it via StateFlow or MutableState.
	- Never mutate state directly in the Composables. Always observe from ViewModel.
	- Use remember and derivedStateOf responsibly to minimize recompositions.
	- Separate Composables into stateful and stateless components. Pass only necessary parameters to stateless Composables.
	- Prefer collectAsStateWithLifecycle() for observing StateFlow in Composables.
	- Keep the UI layer declarative. Avoid using LiveData or imperative state-handling patterns.
### Testing
- Use Espresso or Robolectric for UI testing
- Use JUnit for unit testing
